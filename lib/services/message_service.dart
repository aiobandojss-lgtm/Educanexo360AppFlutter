// lib/services/message_service.dart

import 'dart:io';
import 'package:dio/dio.dart';
import '../models/message.dart';
import 'api_service.dart';
import 'package:path_provider/path_provider.dart';

/// üì® SERVICIO DE MENSAJER√çA
/// Maneja TODOS los endpoints de mensajes, borradores, adjuntos, etc.
class MessageService {
  final ApiService _apiService = ApiService();

  // ========================================
  // üì¨ OBTENER MENSAJES POR BANDEJA
  // ========================================

  Future<Map<String, dynamic>> getMessages({
    required Bandeja bandeja,
    int page = 1,
    int limit = 20,
    String? search,
  }) async {
    try {
      print('üì• Obteniendo mensajes de bandeja: ${bandeja.name}');

      final queryParams = {
        'bandeja': bandeja.name,
        'pagina': page,
        'limite': limit,
      };

      if (search != null && search.isNotEmpty) {
        queryParams['busqueda'] = search;
      }

      final response = await _apiService.get(
        '/mensajes',
        queryParameters: queryParams,
      );

      final data = response['data'] as List<dynamic>? ?? [];
      final messages = data.map((json) => Message.fromJson(json)).toList();

      final meta = response['meta'] ??
          {
            'total': 0,
            'pagina': 1,
            'limite': 20,
            'totalPaginas': 1,
          };

      print('‚úÖ Mensajes obtenidos: ${messages.length}');

      return {
        'messages': messages,
        'meta': meta,
      };
    } catch (e) {
      print('‚ùå Error obteniendo mensajes: $e');
      return {
        'messages': <Message>[],
        'meta': {
          'total': 0,
          'pagina': 1,
          'limite': 20,
          'totalPaginas': 1,
        },
      };
    }
  }

  // ========================================
  // üìñ OBTENER MENSAJE POR ID
  // ========================================

  Future<Message?> getMessageById(String id) async {
    try {
      print('üì• Obteniendo mensaje: $id');
      final response = await _apiService.get('/mensajes/$id');

      if (response['data'] != null) {
        return Message.fromJson(response['data']);
      }

      return null;
    } catch (e) {
      print('‚ùå Error obteniendo mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üìù OBTENER BORRADOR POR ID
  // ========================================

  Future<Message?> getDraftById(String id) async {
    try {
      print('üì• Obteniendo borrador: $id');

      // ‚úÖ AGREGAR populate para destinatarios
      final response = await _apiService.get('/mensajes/borradores/$id',
          queryParameters: {'populate': 'destinatarios'} // ‚Üê AGREGAR ESTO
          );

      if (response['data'] != null) {
        return Message.fromJson(response['data']);
      }

      return null;
    } catch (e) {
      print('‚ùå Error obteniendo borrador: $e');
      rethrow;
    }
  }

  // ========================================
  // ‚úâÔ∏è CREAR MENSAJE NUEVO
  // ========================================

  Future<Message> createMessage({
    List<String>? destinatarios,
    List<String>? cursoIds,
    required String asunto,
    required String contenido,
    Prioridad prioridad = Prioridad.normal,
    List<File>? adjuntos,
  }) async {
    try {
      print('üì§ Creando mensaje...');
      print('   Destinatarios: ${destinatarios?.length ?? 0}');
      print('   Cursos: ${cursoIds?.length ?? 0}');
      print('   Adjuntos: ${adjuntos?.length ?? 0}');

      // Validar que haya al menos destinatarios o cursos
      if ((destinatarios == null || destinatarios.isEmpty) &&
          (cursoIds == null || cursoIds.isEmpty)) {
        throw Exception('Debe seleccionar al menos un destinatario o curso');
      }

      FormData formData = FormData.fromMap({
        'asunto': asunto,
        'contenido': contenido,
        'prioridad': prioridad.name.toUpperCase(),
      });

      // Agregar destinatarios
      if (destinatarios != null && destinatarios.isNotEmpty) {
        for (String destId in destinatarios) {
          formData.fields.add(MapEntry('destinatarios', destId));
        }
      }

      // Agregar cursos
      if (cursoIds != null && cursoIds.isNotEmpty) {
        for (String cursoId in cursoIds) {
          formData.fields.add(MapEntry('cursoIds', cursoId));
        }
      }

      // Agregar adjuntos
      if (adjuntos != null && adjuntos.isNotEmpty) {
        for (File file in adjuntos) {
          String fileName = file.path.split('/').last;
          formData.files.add(MapEntry(
            'adjuntos',
            await MultipartFile.fromFile(file.path, filename: fileName),
          ));
        }
      }

      final response = await _apiService.post(
        '/mensajes',
        data: formData,
      );

      print('‚úÖ Mensaje creado exitosamente');
      return Message.fromJson(response['data']);
    } catch (e) {
      print('‚ùå Error creando mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üíæ GUARDAR BORRADOR
  // ========================================

  Future<Message> saveDraft({
    List<String>? destinatarios,
    List<String>? cursoIds,
    required String asunto,
    required String contenido,
    Prioridad prioridad = Prioridad.normal,
    List<File>? adjuntos,
  }) async {
    try {
      print('üíæ Guardando borrador...');

      // Validaci√≥n m√≠nima
      if (asunto.trim().isEmpty && contenido.trim().isEmpty) {
        throw Exception('Debe escribir al menos el asunto o el contenido');
      }

      // Si hay adjuntos, usar FormData
      if (adjuntos != null && adjuntos.isNotEmpty) {
        FormData formData = FormData.fromMap({
          'asunto': asunto.isEmpty ? '(Sin asunto)' : asunto,
          'contenido': contenido,
          'prioridad': prioridad.name.toUpperCase(),
        });

        // Agregar destinatarios
        if (destinatarios != null && destinatarios.isNotEmpty) {
          for (String destId in destinatarios) {
            formData.fields.add(MapEntry('destinatarios[]', destId));
          }
        }

        // Agregar cursos
        if (cursoIds != null && cursoIds.isNotEmpty) {
          for (String cursoId in cursoIds) {
            formData.fields.add(MapEntry('cursoIds[]', cursoId));
          }
        }

        // Agregar adjuntos
        for (File file in adjuntos) {
          String fileName = file.path.split('/').last;
          formData.files.add(MapEntry(
            'adjuntos',
            await MultipartFile.fromFile(file.path, filename: fileName),
          ));
        }

        final response = await _apiService.post(
          '/mensajes/borradores',
          data: formData,
        );

        print('‚úÖ Borrador guardado con adjuntos');
        return Message.fromJson(response['data']);
      } else {
        // Sin adjuntos, usar JSON
        final response = await _apiService.post(
          '/mensajes/borradores',
          data: {
            'destinatarios': destinatarios ?? [],
            'cursoIds': cursoIds ?? [],
            'asunto': asunto.isEmpty ? '(Sin asunto)' : asunto,
            'contenido': contenido,
            'prioridad': prioridad.name.toUpperCase(),
          },
        );

        print('‚úÖ Borrador guardado sin adjuntos');
        return Message.fromJson(response['data']);
      }
    } catch (e) {
      print('‚ùå Error guardando borrador: $e');
      rethrow;
    }
  }

  // ========================================
  // üìù ACTUALIZAR BORRADOR
  // ========================================

  Future<Message> updateDraft({
    required String draftId,
    List<String>? destinatarios,
    List<String>? cursoIds,
    required String asunto,
    required String contenido,
    Prioridad prioridad = Prioridad.normal,
    List<File>? adjuntos,
    bool clearExistingAttachments = false,
  }) async {
    try {
      print('üìù Actualizando borrador: $draftId');

      // Si hay adjuntos nuevos, usar FormData
      if (adjuntos != null && adjuntos.isNotEmpty) {
        FormData formData = FormData.fromMap({
          'asunto': asunto.isEmpty ? '(Sin asunto)' : asunto,
          'contenido': contenido,
          'prioridad': prioridad.name.toUpperCase(),
          'clearExistingAttachments': clearExistingAttachments,
        });

        // Agregar destinatarios
        if (destinatarios != null && destinatarios.isNotEmpty) {
          for (String destId in destinatarios) {
            formData.fields.add(MapEntry('destinatarios[]', destId));
          }
        }

        // Agregar cursos
        if (cursoIds != null && cursoIds.isNotEmpty) {
          for (String cursoId in cursoIds) {
            formData.fields.add(MapEntry('cursoIds[]', cursoId));
          }
        }

        // Agregar adjuntos
        for (File file in adjuntos) {
          String fileName = file.path.split('/').last;
          formData.files.add(MapEntry(
            'adjuntos',
            await MultipartFile.fromFile(file.path, filename: fileName),
          ));
        }

        final response = await _apiService.put(
          '/mensajes/borradores/$draftId',
          data: formData,
        );

        print('‚úÖ Borrador actualizado con adjuntos');
        return Message.fromJson(response['data']);
      } else {
        // Sin adjuntos nuevos
        final response = await _apiService.put(
          '/mensajes/borradores/$draftId',
          data: {
            'destinatarios': destinatarios ?? [],
            'cursoIds': cursoIds ?? [],
            'asunto': asunto.isEmpty ? '(Sin asunto)' : asunto,
            'contenido': contenido,
            'prioridad': prioridad.name.toUpperCase(),
            'clearExistingAttachments': clearExistingAttachments,
          },
        );

        print('‚úÖ Borrador actualizado');
        return Message.fromJson(response['data']);
      }
    } catch (e) {
      print('‚ùå Error actualizando borrador: $e');
      rethrow;
    }
  }

  // ========================================
  // üóëÔ∏è ELIMINAR BORRADOR
  // ========================================

  Future<void> deleteDraft(String draftId) async {
    try {
      print('üóëÔ∏è Eliminando borrador: $draftId');
      await _apiService.delete('/mensajes/borradores/$draftId');
      print('‚úÖ Borrador eliminado');
    } catch (e) {
      print('‚ùå Error eliminando borrador: $e');
      rethrow;
    }
  }

  // ========================================
  // üöÄ ENVIAR BORRADOR
  // ========================================

  Future<Message> sendDraft(String draftId) async {
    try {
      print('üöÄ Enviando borrador: $draftId');

      // Obtener datos completos del borrador
      final draft = await getDraftById(draftId);
      if (draft == null) {
        throw Exception('Borrador no encontrado');
      }

      // Crear mensaje normal (esto maneja copias a acudientes autom√°ticamente)
      final messageData = {
        'destinatarios': draft.destinatarios.map((d) => d.id).toList(),
        'asunto': draft.asunto,
        'contenido': draft.contenido,
        'prioridad': draft.prioridad.name.toUpperCase(),
      };

      print('üì§ Creando mensaje desde borrador...');
      final response = await _apiService.post('/mensajes', data: messageData);

      // Eliminar el borrador original
      print('üóëÔ∏è Eliminando borrador original...');
      await deleteDraft(draftId);

      print('‚úÖ Borrador enviado exitosamente');
      return Message.fromJson(response['data']);
    } catch (e) {
      print('‚ùå Error enviando borrador: $e');
      rethrow;
    }
  }

  // ========================================
  // üí¨ RESPONDER MENSAJE
  // ========================================

  Future<Message> replyMessage({
    required String originalId,
    required String contenido,
    String? asunto,
    List<File>? adjuntos,
  }) async {
    try {
      print('üí¨ Respondiendo mensaje: $originalId');

      if (adjuntos != null && adjuntos.isNotEmpty) {
        // Con adjuntos
        FormData formData = FormData.fromMap({
          'contenido': contenido,
          'asunto': asunto,
        });

        for (File file in adjuntos) {
          String fileName = file.path.split('/').last;
          formData.files.add(MapEntry(
            'adjuntos',
            await MultipartFile.fromFile(file.path, filename: fileName),
          ));
        }

        final response = await _apiService.post(
          '/mensajes/$originalId/responder',
          data: formData,
        );

        print('‚úÖ Respuesta enviada con adjuntos');
        return Message.fromJson(response['data']);
      } else {
        // Sin adjuntos
        final response = await _apiService.post(
          '/mensajes/$originalId/responder',
          data: {
            'contenido': contenido,
            'asunto': asunto,
          },
        );

        print('‚úÖ Respuesta enviada');
        return Message.fromJson(response['data']);
      }
    } catch (e) {
      print('‚ùå Error respondiendo mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üëÅÔ∏è MARCAR COMO LE√çDO
  // ========================================

  Future<void> markAsRead(String messageId) async {
    try {
      print('üëÅÔ∏è Marcando como le√≠do: $messageId');
      await _apiService.put('/mensajes/$messageId/leer');
      print('‚úÖ Mensaje marcado como le√≠do');
    } catch (e) {
      print('‚ùå Error marcando como le√≠do: $e');
      // No lanzar error, es una operaci√≥n secundaria
    }
  }

  // ========================================
  // üóÇÔ∏è ARCHIVAR MENSAJE
  // ========================================

  Future<void> archiveMessage(String messageId) async {
    try {
      print('üóÇÔ∏è Archivando mensaje: $messageId');
      await _apiService.put('/mensajes/$messageId/archivar');
      print('‚úÖ Mensaje archivado');
    } catch (e) {
      print('‚ùå Error archivando mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üì§ DESARCHIVAR MENSAJE
  // ========================================

  Future<void> unarchiveMessage(String messageId) async {
    try {
      print('üì§ Desarchivando mensaje: $messageId');
      await _apiService.put('/mensajes/$messageId/desarchivar');
      print('‚úÖ Mensaje desarchivado');
    } catch (e) {
      print('‚ùå Error desarchivando mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üóëÔ∏è ELIMINAR MENSAJE (a papelera)
  // ========================================

  Future<void> deleteMessage(String messageId) async {
    try {
      print('üóëÔ∏è Eliminando mensaje: $messageId');
      await _apiService.put('/mensajes/$messageId/eliminar');
      print('‚úÖ Mensaje movido a papelera');
    } catch (e) {
      print('‚ùå Error eliminando mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // ‚ôªÔ∏è RESTAURAR MENSAJE
  // ========================================

  Future<void> restoreMessage(String messageId) async {
    try {
      print('‚ôªÔ∏è Restaurando mensaje: $messageId');
      await _apiService.put('/mensajes/$messageId/restaurar');
      print('‚úÖ Mensaje restaurado');
    } catch (e) {
      print('‚ùå Error restaurando mensaje: $e');
      rethrow;
    }
  }

  // ========================================
  // üí• ELIMINAR PERMANENTEMENTE
  // ========================================

  Future<void> deletePermanently(String messageId) async {
    try {
      print('üí• Eliminando permanentemente: $messageId');
      await _apiService.delete('/mensajes/$messageId');
      print('‚úÖ Mensaje eliminado definitivamente');
    } catch (e) {
      print('‚ùå Error eliminando permanentemente: $e');
      rethrow;
    }
  }

  // ========================================
  // üìé DESCARGAR ADJUNTO
  // ========================================

// ========================================
// üìé DESCARGAR ADJUNTO - IMPLEMENTACI√ìN COMPLETA
// ========================================

  Future<Map<String, dynamic>> downloadAttachment(
    String messageId,
    String attachmentId,
    String fileName,
  ) async {
    try {
      print('üìé Descargando adjunto: $fileName');
      print('   Mensaje ID: $messageId');
      print('   Adjunto ID: $attachmentId');

      // 1Ô∏è‚É£ Obtener la ruta de descarga
      Directory? directory;

      if (Platform.isAndroid) {
        directory = await getExternalStorageDirectory();
        if (directory != null) {
          final downloadsPath =
              directory.path.split('/Android')[0] + '/Download';
          directory = Directory(downloadsPath);

          if (!await directory.exists()) {
            await directory.create(recursive: true);
          }
        }
      } else if (Platform.isIOS) {
        directory = await getApplicationDocumentsDirectory();
      }

      if (directory == null) {
        throw Exception('No se pudo obtener el directorio de descarga');
      }

      final filePath = '${directory.path}/$fileName';
      print('üíæ Ruta de descarga: $filePath');

      // 2Ô∏è‚É£ Descargar el archivo
      final url = '/mensajes/$messageId/adjuntos/$attachmentId';
      print('üåê URL: $url');

      await _apiService.download(url, filePath);

      print('‚úÖ Archivo descargado exitosamente en: $filePath');

      // 3Ô∏è‚É£ Retornar resultado exitoso
      return {
        'success': true,
        'message': 'Archivo descargado exitosamente',
        'path': filePath,
      };
    } catch (e) {
      print('‚ùå Error descargando adjunto: $e');
      return {
        'success': false,
        'message': 'Error al descargar: $e',
      };
    }
  }

  Future<void> _scanFile(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        print('üì± Archivo guardado correctamente');
      }
    } catch (e) {
      print('‚ö†Ô∏è Error: $e');
    }
  }

  // ========================================
  // üë• OBTENER DESTINATARIOS DISPONIBLES
  // ========================================

  Future<List<User>> getAvailableRecipients() async {
    try {
      print('üë• Obteniendo destinatarios disponibles...');

      final response =
          await _apiService.get('/mensajes/destinatarios-disponibles');

      final data = response['data'] as List<dynamic>? ?? [];
      final recipients = data.map((json) => User.fromJson(json)).toList();

      print('‚úÖ Destinatarios obtenidos: ${recipients.length}');
      return recipients;
    } catch (e) {
      print('‚ùå Error obteniendo destinatarios: $e');
      return [];
    }
  }

  // ========================================
  // üìö OBTENER CURSOS DISPONIBLES
  // ========================================

  Future<List<Course>> getAvailableCourses() async {
    try {
      print('üìö Obteniendo cursos disponibles...');

      final response = await _apiService.get('/mensajes/cursos-disponibles');

      final data = response['data'] as List<dynamic>? ?? [];
      final courses = data.map((json) => Course.fromJson(json)).toList();

      print('‚úÖ Cursos obtenidos: ${courses.length}');
      return courses;
    } catch (e) {
      print('‚ùå Error obteniendo cursos: $e');
      return [];
    }
  }
}
